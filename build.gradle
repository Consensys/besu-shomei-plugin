import groovy.transform.Memoized

/*
 * Copyright ConsenSys 2023
 *]
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

plugins {
    id 'com.diffplug.spotless' version '6.21.0'
    id 'com.github.hierynomus.license' version '0.16.1'
    id 'io.spring.dependency-management' version '1.1.0'
    id 'com.github.jk1.dependency-license-report' version '2.1'
    id 'net.ltgt.errorprone' version '3.0.1' apply false
    id 'net.consensys.besu-plugin-distribution' version '0.1.4'
}

apply plugin: 'net.consensys.besu-plugin-distribution'
apply plugin: 'io.spring.dependency-management'
apply plugin: 'net.ltgt.errorprone'
apply plugin: 'jacoco'
apply from: "${rootDir}/gradle/versions.gradle"
apply from: "${rootDir}/gradle/check-licenses.gradle"

group = 'net.consensys.shomei.besu.plugin'
//version = '0.1.0'
version = project.hasProperty('releaseVersion') ? project.getProperty('releaseVersion') : 'snapshot'

java {
    sourceCompatibility = 21
    targetCompatibility = 21
}

defaultTasks 'build', 'checkLicenses', 'javadoc', 'plugin'

repositories {
    mavenCentral()
    maven {
        url "https://dl.cloudsmith.io/public/libp2p/jvm-libp2p/maven/"
        content { includeGroupByRegex('io\\.libp2p($|\\..*)') }
    }
    maven {
        url "https://artifacts.consensys.net/public/linea-arithmetization/maven/"
        content {
            includeGroupByRegex('net\\.consensys\\.linea\\..*?')
        }
    }
    mavenLocal()
}

apply plugin: 'com.diffplug.spotless'
spotless {
    java {
        // This path needs to be relative to each project
        target fileTree('.') {
            include '**/*.java'
            exclude '**/.gradle/**'
            exclude '**/resources'
            exclude '**/src/*/generated'
            exclude '**/src/*/generated_tests'
            exclude '**/build/**'
        }
        removeUnusedImports()
        googleJavaFormat('1.17.0')
        importOrder 'net.consensys', 'java', ''
        trimTrailingWhitespace()
        endWithNewline()
        licenseHeaderFile "${rootDir}/gradle/spotless.java.license"
    }
}

tasks.withType(JavaCompile) {
    options.compilerArgs += [
            '-Xlint:unchecked',
            '-Xlint:cast',
            '-Xlint:rawtypes',
            '-Xlint:overloads',
            '-Xlint:divzero',
            '-Xlint:finally',
            '-Xlint:static',
            '-Werror',
    ]
    options.forkOptions.jvmArgs += [
            '--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
            '--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
            '--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED'
    ]

    options.errorprone {
        enabled = !'true'.equalsIgnoreCase(System.getProperty('avt.disableErrorProne'))
        disableWarningsInGeneratedCode

        // Our equals need to be symmetric, this checker doesn't respect that
        check('EqualsGetClass', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // We use the JSR-305 annotations instead of the Google annotations
        check('ImmutableEnumChecker', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // Storing a lambda to avoid code duplication is not a bad thing
        check('UnnecessaryLambda', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // Generates a ton of false alarms for no real value
        check('LongDoubleConversion', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('InlineMeSuggester', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('CanIgnoreReturnValueSuggester', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('DirectInvocationOnMock', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // We don't apply strict javadoc requirements yet
        check('EmptyBlockTag', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('MissingSummary', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // Force strict compliance with Java naming conventions
        check('JavaCase', net.ltgt.gradle.errorprone.CheckSeverity.WARN)

        // Check for uses of == that should probably be .equals
        check('ReferenceComparison', net.ltgt.gradle.errorprone.CheckSeverity.WARN)

        // These checks are imported from errorprone-checks dependency but not required in Teku
        check('MethodInputParametersMustBeFinal', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('BannedMethod', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('ExperimentalCliOptionMustBeCorrectlyDisplayed', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // These are experimental checks that we want enabled
        check('MissingBraces', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InsecureCryptoUsage', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('WildcardImport', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('DeduplicateConstants', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('RedundantOverride', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('RedundantThrows', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('UnnecessarilyFullyQualified', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InitializeInline', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('ClassName', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InterfaceWithOnlyStatics', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('PackageLocation', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
    }
    options.encoding = 'UTF-8'
}

sourceSets {
    testSupport {
        java {
            srcDir 'src/testSupport/java'
        }
        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}

configurations {
    testSupportImplementation
    testSupportRuntimeOnly
}

dependencies {
    errorprone("com.google.errorprone:error_prone_core")
    errorprone("tech.pegasys.tools.epchecks:errorprone-checks")

    compileOnly 'net.consensys.linea.zktracer:arithmetization'

    implementation 'io.vertx:vertx-web-client'

    testImplementation 'net.consensys.linea.zktracer:arithmetization'
    testImplementation sourceSets.testSupport.output
    testImplementation 'io.vertx:vertx-junit5'
    testImplementation 'org.assertj:assertj-core'
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'org.junit.jupiter:junit-jupiter-params'
    testImplementation 'org.mockito:mockito-core'
    testImplementation 'org.mockito:mockito-junit-jupiter'
}

jar {
    archiveBaseName = 'besu-shomei-plugin'

    manifest {
        attributes(
                'Specification-Title': archiveBaseName.get(),
                'Specification-Version': rootProject.version,
                'Implementation-Title': archiveBaseName.get(),
                'Implementation-Version': calculateVersion()
        )
    }
}

distributions {
    main {
        distributionBaseName = 'besu-shomei-plugin'
    }
}

test {
    useJUnitPlatform()
}

task testSupportJar(type: Jar) {
    archiveClassifier.set("test-support")
    from sourceSets.testSupport.output
    description = "Packages the test implementation classes"
    group = "build"
}
build.dependsOn(testSupportJar)

task plugin(dependsOn: 'jar') {
    group 'build'
    description 'Alias for the jar task'
}


@Memoized
def calculateVersion() {
    String version = rootProject.version
    if (version.endsWith("-SNAPSHOT")) {
        version = version.replace("-SNAPSHOT", "-dev-" + getCheckedOutGitCommitHash())
    }
    return version
}

def getCheckedOutGitCommitHash(length = 8) {
    try {
        def gitFolder = "$projectDir/.git/"
        if (!file(gitFolder).isDirectory()) {
            // We are in a submodule.  The file's contents are `gitdir: <gitFolder>\n`.
            // Read the file, cut off the front, and trim the whitespace.
            gitFolder = file(gitFolder).text.substring(length).trim() + "/"
        }
        def takeFromHash = length
        /*
         * '.git/HEAD' contains either
         *      in case of detached head: the currently checked out commit hash
         *      otherwise: a reference to a file containing the current commit hash
         */
        def head = new File(gitFolder + "HEAD").text.split(":") // .git/HEAD
        def isCommit = head.length == 1 // e5a7c79edabbf7dd39888442df081b1c9d8e88fd

        if (isCommit) return head[0].trim().take(takeFromHash) // e5a7c79edabb

        def refHead = new File(gitFolder + head[1].trim()) // .git/refs/heads/master
        refHead.text.trim().take takeFromHash
    } catch (Exception e) {
        logger.warn('Could not calculate git commit, using "xxxxxxxx" (run with --info for stacktrace)')
        logger.info('Error retrieving git commit', e)
        return "xxxxxxxx"
    }
}
